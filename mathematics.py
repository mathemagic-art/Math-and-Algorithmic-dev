from sympy import *
import numpy as np
import matplotlib.pyplot as plt

import math


x = Symbol('x')
import warnings
warnings.filterwarnings("error")
warnings.filterwarnings("ignore", category=UserWarning)


# done by Shokhrukh
def Newton_Method(input_function: str, first_guess: int, number_of_iterations: int):
    try:
        input_function = sympify(input_function.replace('e', 'E')) #replaces 
        f = lambdify(x, input_function) #lambdify expression of the input function
        f_d = lambdify(x, diff(input_function, x))  #lambdify expression of the derivative of the input function
        x_i = first_guess
        for i in range(number_of_iterations):
            x_i = x_i - (f(x_i)/f_d(x_i))
        if f(x_i) > 0.000001:
            return "Please check the function. Probably, it does not have any roots"
        else:
            return x_i
    except RuntimeWarning:
        return "Please change your first guess. Perhaps, the method came across with vertex or new x_i are diverging instead of converging."

#Done by Aisha
def Differentiating_Calculator(function: str):

    function = function.replace('e', 'E')
    function = sympify(function) #this is input (be careful with writing the power of exp, because here we dont use usal (**) but just take in breakets 
    function_prime = function.diff(x)  
    function = lambdify(x, function) #idetifiying respect to which variable we are taking variable
    #print in the space (f_prime) it will give the answer
    return function



########################################################################################################################
# done by

# -*- coding: utf-8 -*-
"""Rectangle_Method

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y3A2P3HRaojlbwXJQD7TXJrPfv5P3caQ
"""

# Commented out IPython magic to ensure Python compatibility.


def rectangle_Method(func: str, a: int, b: int, n: int):
    f = lambdify(x, func)
    x = symbols('x')
    f = lambdify(x, func)
    dx = (b - a)/n
    total = 0.0
    for i in range (n):
            total = total + f((a + (i*dx)))
    Area = dx*total
    return Area
      
# rectangle_Method(f, a, b)

# def rectangle_method_graph(f,a,b):
#     X = np.linspace(a,b,100)
#     x = np.linspace(a,b,n+1)
#     Y = f(X)
#     plt.figure(figsize = (15,10))
#     plt.plot(X,Y, color='black', linewidth=2, markersize=50)

#     for i in range(n):
#         a = [x[i],x[i],x[i+1],x[i+1]]
#         b = [0,f(x[i]),f(x[i]),0]
#         plt.fill_between(a,b, edgecolor='black')
#         plt.savefig('Rectangle_Method_Graph.png')
# rectangle_method_graph(f,a,b)


########################################################################################################################
# done by


# -*- coding: utf-8 -*-
"""scipy_taylor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ey3mwtRqO2-3FID47Pc0F3hZfdREiJwn
"""

# Commented out IPython magic to ensure Python compatibility.

# function = input("Please enter the function: ")
# function = function.replace('e', 'E')
# n = int(input("Please enter the number of terms for expansion: "))
# c = int(input("Please enter the centre: "))
# taylorPolynomial = str(lambdify(x, function)(c))
# for i in range(1, n):
#     diff = str(sym.lambdify(x, sym.diff(function, x, i))(c))
#     taylorPolynomial += '+' + diff +'/'+str(factorial(i))+'*(x-{})**{}'.format(c, i)
# taylorPolynomial = sym.sympify(taylorPolynomial, rational=True)
# taylorPolynomial

# arr = np.linspace(c-c, c+c, 100)
# y=sym.lambdify(x, function)(arr)
# y_2=sym.lambdify(x, taylorPolynomial)(arr)
# plt.plot(arr,y , label='Function', color = "blue")
# plt.plot(arr, y_2, label='Taylor series', color = "red")
# plt.legend()